/**
 * Problem
 * You are given a 3×3 grid of integers. Let Gi,j denote the integer in the i-th row and j-th column of the grid, where i and j are 0-indexed. The integer in the middle of the grid, G1,1, is missing. Find the maximum number of rows, columns, and diagonals of this square, that form sequences which are arithmetic progressions. You can replace the missing number with any integer.
 * <p>
 * An arithmetic progression (also known as arithmetic sequence) is a sequence of numbers such that the difference between consecutive terms is constant. In mathematical terms, this can be represented as an=an−1+d, where d is the common difference. In this problem, a sequence can be the 3 numbers in either a row, column or diagonal. We are looking to replace the missing value by an integer that maximizes the number of arithmetic progressions that can be found in the resulting set of sequences.
 * <p>
 * Two sequences are considered different if they are from different rows, columns, or diagonals. For example, the sequence {2,4,6} across the middle row and {2,4,6} across the top row will be counted as two sequences but the sequences {2,4,6} and {6,4,2} across the same row, column, or diagonal will be counted as one sequence.
 * <p>
 * Input
 * The first line of the input gives the number of test cases, T. T test cases follow.
 * Each test case consists of 3 lines.
 * The first line of each test case contains 3 integers, G0,0, G0,1, and G0,2.
 * The second line of each test case contains 2 integers, G1,0 and G1,2.
 * The last line of each test case contains 3 integers, G2,0, G2,1, and G2,2.
 * Output
 * For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum possible number of arithmetic progressions that can be generated by the rows, columns, and diagonals of the grid after setting the missing element.
 * <p>
 * Limits
 * Memory limit: 1 GB.
 * 1≤T≤100.
 * Gi,j are integers, for all i,j.
 * <p>
 * Test Set 1
 * Time limit: 20 seconds.
 * |Gi,j|≤50, for all i,j.
 * Test Set 2
 * Time limit: 40 seconds.
 * |Gi,j|≤109, for all i,j.
 **/
package solutions;

import java.util.*;

public class ArithmeticSquare {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int iterations = scanner.nextInt();
        scanner.nextLine();

        for (int i = 1; i <= iterations; i++) {
            int[][] grid = new int[3][3];
            String[] firstRow = scanner.nextLine().split(" ");
            for (int index = 0; index < 3; index++) {
                int value = Integer.parseInt(firstRow[index]);
                grid[0][index] = value;
            }

            String[] secondRow = new String[3];
            String[] scannerString = scanner.nextLine().split(" ");
            secondRow[0] = scannerString[0];
            secondRow[2] = scannerString[1];

            for (int index = 0; index < 3; index++) {
                if (index == 1) {
                    continue;
                }
                int value = Integer.parseInt(secondRow[index]);
                grid[1][index] = value;
            }
            String[] thirdRow = scanner.nextLine().split(" ");
            for (int index = 0; index < 3; index++) {
                int value = Integer.parseInt(thirdRow[index]);
                grid[2][index] = value;
            }
            System.out.println("Case #" + i + ": " + countProgressions(grid));
        }
    }

    private static void getOrPut(Map<Integer, List<Result>> sequences, List<Result> result, int B) {
        if (sequences.containsKey(B)) {
            sequences.get(B).addAll(result);
        } else {
            sequences.put(B, result);
        }
    }

    private static Set<Integer> calculatePossibleValuesOfB(int[][] grid) {
        Set<Integer> result = new HashSet<>();
        int B = (grid[0][0] + grid[2][2]) / 2; //diagonal top left
        result.add(B);
        B = (grid[0][1] + grid[2][1]) / 2; //middle column
        result.add(B);
        B = (grid[0][2] + grid[2][0]) / 2; //diagonal top right
        result.add(B);
        B = (grid[1][0] + grid[1][2]) / 2; //middle row
        result.add(B);
        return result;
    }

    private static int countProgressions(int[][] grid) {
        int maxProgression = 0;
        Map<Integer, List<Result>> sequences = new HashMap<>();

        for (Integer B : calculatePossibleValuesOfB(grid)) {
            grid[1][1] = B;
            //check top left diagonal
            int difference5 = grid[0][0] - grid[1][1];
            int difference6 = grid[1][1] - grid[2][2];
            if (difference5 == difference6) {
                List<Result> result = new ArrayList<>();
                result.add(new Result(0, 0));
                result.add(new Result(1, 1));
                result.add(new Result(2, 2));
                sequences.put(B, result);
            }

            //check top right diagonal
            int difference7 = grid[2][0] - grid[1][1];
            int difference8 = grid[1][1] - grid[0][2];
            if (difference7 == difference8) {
                List<Result> result = new ArrayList<>();
                result.add(new Result(2, 0));
                result.add(new Result(1, 1));
                result.add(new Result(0, 2));
                getOrPut(sequences, result, B);
            }
            for (int row = 0; row < 3; row++) {
                int difference1 = grid[row][0] - grid[row][1];
                int difference2 = grid[row][1] - grid[row][2];
                if (difference1 == difference2) {
                    List<Result> result = new ArrayList<>();
                    result.add(new Result(row, 0));
                    result.add(new Result(row, 1));
                    result.add(new Result(row, 2));
                    getOrPut(sequences, result, B);
                }

                int difference3 = grid[0][row] - grid[1][row];
                int difference4 = grid[1][row] - grid[2][row];
                if (difference3 == difference4) {
                    List<Result> result = new ArrayList<>();
                    result.add(new Result(0, row));
                    result.add(new Result(1, row));
                    result.add(new Result(2, row));
                    getOrPut(sequences, result, B);
                }
            }
            if (maxProgression < getMaxLength(sequences)) {
                maxProgression = getMaxLength(sequences);
            }
        }

        return maxProgression;
    }

    private static int getMaxLength(Map<Integer, List<Result>> sequences) {
        return sequences.values().stream().map(List::size).max(Integer::compareTo).orElse(0) / 3; //Divide by three becausee each sequence has three "Results"
    }

    static class Result {
        private final int row;
        private final int column;

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Result result = (Result) o;
            return row == result.row && column == result.column;
        }

        @Override
        public int hashCode() {
            return Objects.hash(row, column);
        }

        public Result(int row, int column) {
            this.row = row;
            this.column = column;
        }
    }
}
